<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ficha Pathfinder 2E ‚Äî Editor (Campos + Coment√°rios)</title>

<!-- pdf.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.139/pdf.min.js"></script>
<!-- pdf-lib -->
<script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.20.0/dist/pdf-lib.min.js"></script>

<style>
  :root { --accent:#007bff; --note-bg:#fff9a6; --note-border:#d6c84b; }
  body { font-family: Inter, Arial, sans-serif; margin:0; padding:16px; background:#f3f4f6; color:#111; }
  header { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px; }
  h1 { font-size:18px; margin:0; }
  button.primary { background:var(--accent); color:#fff; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; }
  #viewer { max-width:1100px; margin:12px auto; }
  .page { position:relative; margin:14px auto; box-shadow:0 4px 12px rgba(0,0,0,0.08); background:#ddd; }
  canvas.pdf-page { display:block; }
  .overlay { position:absolute; left:0; top:0; pointer-events:none; }
  input.field { position:absolute; pointer-events:auto; border:1px solid rgba(0,0,0,0.18); background:rgba(255,255,255,0.92); padding:2px 28px 2px 6px; font-size:12px; border-radius:3px; box-sizing:border-box; }
  /* √≠cone dentro do campo (coment√°rio) */
  button.cmt-btn { position:absolute; pointer-events:auto; border:0; background:transparent; cursor:pointer; font-size:14px; width:22px; height:22px; display:flex; align-items:center; justify-content:center; }
  /* pop-up de coment√°rio (inicialmente hidden) */
  .cmt-popup { position:absolute; pointer-events:auto; background:var(--note-bg); border:1px solid var(--note-border); box-shadow:0 6px 18px rgba(0,0,0,0.12); padding:8px; border-radius:6px; min-width:160px; max-width:320px; z-index:50; }
  .cmt-popup textarea { width:100%; min-height:48px; max-height:240px; resize:vertical; border:0; background:transparent; font-size:13px; outline:none; }
  .cmt-popup .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:6px; }
  .cmt-popup button { padding:6px 8px; border-radius:6px; border:0; cursor:pointer; }
  .cmt-popup button.save { background:var(--accent); color:#fff; }
  .cmt-popup button.close { background:#eee; }
  .note-indicator { position:absolute; width:8px; height:8px; border-radius:50%; background:#f59e0b; right:6px; top:6px; box-shadow:0 1px 3px rgba(0,0,0,0.2); }
  .muted { color:#666; font-size:13px; }
</style>
</head>
<body>
<header>
  <div>
    <h1>Ficha de Personagem Pathfinder 2E</h1>
    <div class="muted">Comente clicando no √≠cone dentro do campo ‚Äî coment√°rio aparece acima do campo.</div>
  </div>
  <div>
    <button id="savePdf" class="primary">Salvar PDF preenchido + coment√°rios</button>
  </div>
</header>

<main id="viewer"></main>

<script>
const PDF_FILENAME = 'pdfcoffee.com_pathfinder-2e-ficha-de-personagem-editavel-pdf-free.pdf';
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.139/pdf.worker.min.js';

let rawPdfBuffer = null;
let pages = []; // { page, viewport, canvas, overlay }
let commentsStore = {}; // key: pageIndex|fieldName -> comment text

window.addEventListener('load', () => init());

async function init() {
  try {
    const resp = await fetch(PDF_FILENAME);
    if (!resp.ok) throw new Error('PDF n√£o encontrado. Verifique o nome/path no reposit√≥rio.');
    rawPdfBuffer = await resp.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: rawPdfBuffer }).promise;
    const viewer = document.getElementById('viewer');

    for (let p = 1; p <= pdf.numPages; p++) {
      const page = await pdf.getPage(p);
      const scale = 1.5;
      const viewport = page.getViewport({ scale });
      const container = document.createElement('div');
      container.className = 'page';
      container.style.width = viewport.width + 'px';
      container.style.height = viewport.height + 'px';

      const canvas = document.createElement('canvas');
      canvas.className = 'pdf-page';
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      container.appendChild(canvas);

      const overlay = document.createElement('div');
      overlay.className = 'overlay';
      overlay.style.width = viewport.width + 'px';
      overlay.style.height = viewport.height + 'px';
      overlay.style.left = '0';
      overlay.style.top = '0';
      container.appendChild(overlay);

      viewer.appendChild(container);

      const ctx = canvas.getContext('2d');
      await page.render({ canvasContext: ctx, viewport }).promise;

      // extrair anota√ß√µes / widgets (campos de formul√°rio)
      const annotations = await page.getAnnotations({ intent: 'display' });
      annotations.forEach(ann => {
        if (!ann.fieldName) return;
        // normalizar rect e converter para viewport
        const rect = pdfjsLib.Util.normalizeRect(ann.rect);
        const [x1,y1,x2,y2] = rect;
        const [vx1, vy1] = viewport.convertToViewportPoint(x1, y1);
        const [vx2, vy2] = viewport.convertToViewportPoint(x2, y2);
        const left = Math.min(vx1, vx2);
        const top = Math.min(vy1, vy2);
        const width = Math.abs(vx2 - vx1);
        const height = Math.max(18, Math.abs(vy2 - vy1)); // garantir uma altura m√≠nima

        // criar input
        const input = document.createElement('input');
        input.className = 'field';
        input.type = 'text';
        input.value = ann.fieldValue || '';
        input.style.left = left + 'px';
        input.style.top = top + 'px';
        input.style.width = Math.max(40, width) + 'px';
        input.style.height = height + 'px';
        input.dataset.fieldName = ann.fieldName;
        input.dataset.pageIndex = p - 1;
        input.title = ann.fieldName;

        // bot√£o coment√°rio (dentro do campo, √† direita)
        const cbtn = document.createElement('button');
        cbtn.className = 'cmt-btn';
        cbtn.innerHTML = 'üí¨';
        // posicione o bot√£o sobre o input (ajusta para o padding)
        cbtn.style.left = (left + parseFloat(input.style.width) - 22) + 'px';
        cbtn.style.top = top + 'px';
        cbtn.dataset.fieldName = ann.fieldName;
        cbtn.dataset.pageIndex = p - 1;
        cbtn.ariaLabel = 'Coment√°rio';

        // indicativo se j√° tem coment√°rio (pequeno ponto)
        const indicator = document.createElement('div');
        indicator.className = 'note-indicator';
        indicator.style.display = 'none'; // inicial: escondido
        indicator.style.left = (left + parseFloat(input.style.width) - 18) + 'px';
        indicator.style.top = (top + 6) + 'px';

        overlay.appendChild(input);
        overlay.appendChild(cbtn);
        overlay.appendChild(indicator);

        // evento abrir/fechar popup
        cbtn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          toggleCommentPopup(input, cbtn, indicator);
        });

        // clique no input deve apenas focar (sem abrir o coment√°rio)
        input.addEventListener('click', (ev) => ev.stopPropagation());

        // fechar popups ao clicar fora
        document.addEventListener('click', (ev) => {
          // se clicou fora de popups/√≠cones, fecha qualquer popup aberto
          closeAllCommentPopups();
        });

      });

      pages.push({ page, viewport, canvas, overlay });
    }

  } catch (err) {
    alert('Erro ao carregar PDF: ' + (err.message || err));
    console.error(err);
  }
}

// mant√©m somente um popup aberto por vez
function closeAllCommentPopups() {
  document.querySelectorAll('.cmt-popup').forEach(n => n.remove());
}

function popupIdFor(input) {
  return 'cmt-' + (input.dataset.pageIndex) + '-' + encodeURIComponent(input.dataset.fieldName);
}

function toggleCommentPopup(input, button, indicator) {
  const existing = document.getElementById(popupIdFor(input));
  if (existing) {
    existing.remove();
    return;
  }
  closeAllCommentPopups();

  // criar popup
  const popup = document.createElement('div');
  popup.className = 'cmt-popup';
  popup.id = popupIdFor(input);

  const ta = document.createElement('textarea');
  ta.placeholder = 'Escreva um coment√°rio...';
  // carregar coment√°rio salvo (se houver)
  const key = `${input.dataset.pageIndex}|${input.dataset.fieldName}`;
  ta.value = commentsStore[key] || '';

  const actions = document.createElement('div');
  actions.className = 'actions';
  const btnSave = document.createElement('button');
  btnSave.textContent = 'Salvar';
  btnSave.className = 'save';
  const btnClose = document.createElement('button');
  btnClose.textContent = 'Fechar';
  btnClose.className = 'close';

  actions.appendChild(btnClose);
  actions.appendChild(btnSave);

  popup.appendChild(ta);
  popup.appendChild(actions);

  // posicionar popup **acima** do campo (ajuste se ultrapassar topo)
  const overlay = input.parentElement;
  const inputRect = input.getBoundingClientRect();
  const overlayRect = overlay.getBoundingClientRect();
  const popupLeft = (parseFloat(input.style.left) || inputRect.left - overlayRect.left);
  // calcular top: acima do input
  const popupHeightGuess = 110; // valor inicial para posicionar acima
  let popupTop = (parseFloat(input.style.top) || inputRect.top - overlayRect.top) - popupHeightGuess - 8;
  if (popupTop < 8) popupTop = 8; // n√£o ultrapassar topo da p√°gina
  popup.style.left = popupLeft + 'px';
  popup.style.top = popupTop + 'px';

  // inserir no overlay
  overlay.appendChild(popup);
  ta.focus();

  // salvar a√ß√£o
  btnSave.addEventListener('click', (ev) => {
    ev.stopPropagation();
    const text = ta.value.trim();
    if (text) {
      commentsStore[key] = text;
      indicator.style.display = 'block';
    } else {
      delete commentsStore[key];
      indicator.style.display = 'none';
    }
    popup.remove();
  });

  btnClose.addEventListener('click', (ev) => {
    ev.stopPropagation();
    popup.remove();
  });

  // impedir fechamento imediato ao clicar dentro do popup
  popup.addEventListener('click', (ev) => ev.stopPropagation());
}

// SALVAR PDF: aplica campos e desenha coment√°rios
document.getElementById('savePdf').addEventListener('click', async () => {
  if (!rawPdfBuffer) return alert('PDF n√£o carregado.');

  try {
    const pdfDoc = await PDFLib.PDFDocument.load(rawPdfBuffer);
    // tentar obter form (pode falhar se o PDF n√£o tiver formul√°rio compat√≠vel)
    let form = null;
    try { form = pdfDoc.getForm(); } catch {}

    // aplicar valores dos inputs
    document.querySelectorAll('input.field').forEach(inp => {
      const name = inp.dataset.fieldName;
      const val = inp.value || '';
      if (form) {
        try { form.getTextField(name).setText(val); } catch (e) { /* ignora se n√£o existir */ }
      } else {
        // se n√£o houver form, desenhar texto diretamente na p√°gina
        const pageIndex = Number(inp.dataset.pageIndex);
        const page = pdfDoc.getPage(pageIndex);
        if (page) {
          // converter coords canvas->pdf
          const pageInfo = pages[pageIndex];
          const pdfW = page.getWidth(), pdfH = page.getHeight();
          const scaleX = pdfW / pageInfo.canvas.width;
          const scaleY = pdfH / pageInfo.canvas.height;
          const rect = inp.getBoundingClientRect();
          const canvRect = pageInfo.canvas.getBoundingClientRect();
          const px = rect.left - canvRect.left;
          const py = rect.top - canvRect.top;
          const pdfX = px * scaleX;
          const pdfY = (pageInfo.canvas.height - (py + rect.height)) * scaleY;
          // desenha texto
          page.drawText(val, { x: pdfX + 2, y: pdfY + 2, size: 10, color: PDFLib.rgb(0,0,0) });
        }
      }
    });

    // desenhar coment√°rios (se houver)
    for (const k in commentsStore) {
      const [pageIdxStr, fieldName] = k.split('|');
      const pageIndex = Number(pageIdxStr);
      const commentText = commentsStore[k];
      const pageInfo = pages[pageIndex];
      if (!pageInfo) continue;

      // achar o input DOM correspondente para posicionar a nota
      const input = Array.from(document.querySelectorAll('input.field')).find(i =>
        i.dataset.pageIndex == pageIndex && i.dataset.fieldName === fieldName
      );
      if (!input) continue;

      const pdfPage = pdfDoc.getPage(pageIndex);
      const pdfW = pdfPage.getWidth(), pdfH = pdfPage.getHeight();
      const scaleX = pdfW / pageInfo.canvas.width;
      const scaleY = pdfH / pageInfo.canvas.height;

      const rect = input.getBoundingClientRect();
      const canvRect = pageInfo.canvas.getBoundingClientRect();
      const px = rect.left - canvRect.left;
      const py = rect.top - canvRect.top;
      const pw = rect.width;
      const ph = rect.height;

      // posicionar nota **acima do campo** no PDF
      const pdfX = px * scaleX;
      const pdfY = (pageInfo.canvas.height - (py + ph + 6)) * scaleY; // 6pt acima
      const noteWidth = Math.min(220, (pw * scaleX) + 60);
      const noteHeight = Math.max(20, Math.min(180, (commentText.split('\n').length * 14) + 12));

      // desenhar ret√¢ngulo amarelo e texto em cima
      pdfPage.drawRectangle({
        x: pdfX,
        y: pdfY,
        width: noteWidth,
        height: noteHeight,
        color: PDFLib.rgb(1, 0.95, 0.6),
        borderColor: PDFLib.rgb(0.82,0.71,0.18),
        borderWidth: 0.8,
      });

      // dividir texto em linhas simples (pdf-lib n√£o quebra linhas automaticamente)
      const maxCharsPerLine = 45;
      const lines = [];
      const words = commentText.split(/\s+/);
      let line = '';
      words.forEach(w => {
        if ((line + ' ' + w).trim().length <= maxCharsPerLine) {
          line = (line + ' ' + w).trim();
        } else {
          lines.push(line);
          line = w;
        }
      });
      if (line) lines.push(line);

      // desenhar cada linha
      const fontSize = 10;
      for (let i = 0; i < lines.length; i++) {
        const ty = pdfY + noteHeight - (fontSize + 6) - (i * (fontSize + 2));
        pdfPage.drawText(lines[i], { x: pdfX + 6, y: ty, size: fontSize, color: PDFLib.rgb(0,0,0) });
      }
    }

    if (form) {
      try { form.flatten(); } catch(e) {}
    }

    const pdfBytes = await pdfDoc.save();
    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'Ficha_Pathfinder_Preenchida.pdf';
    document.body.appendChild(link);
    link.click();
    link.remove();
    setTimeout(() => URL.revokeObjectURL(link.href), 2000);
    alert('PDF gerado com coment√°rios incorporados. Verifique seu download.');

  } catch (err) {
    console.error(err);
    alert('Erro ao gerar PDF: ' + (err.message || err));
  }
});
</script>
</body>
</html>
